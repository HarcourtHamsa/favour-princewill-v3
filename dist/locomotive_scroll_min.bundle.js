/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/lib/locomotive-scroll.min.js":
/*!******************************************!*\
  !*** ./src/lib/locomotive-scroll.min.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n!function (t, e) {\n  \"object\" == ( false ? 0 : _typeof(exports)) && \"undefined\" != \"object\" ? module.exports = e() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n}(this, function () {\n  \"use strict\";\n\n  function t(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function e(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var s = e[i];\n      s.enumerable = s.enumerable || !1, s.configurable = !0, \"value\" in s && (s.writable = !0), Object.defineProperty(t, s.key, s);\n    }\n  }\n\n  function i(t, i, s) {\n    return i && e(t.prototype, i), s && e(t, s), t;\n  }\n\n  function s(t, e, i) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = i, t;\n  }\n\n  function n(t, e) {\n    var i = Object.keys(t);\n\n    if (Object.getOwnPropertySymbols) {\n      var s = Object.getOwnPropertySymbols(t);\n      e && (s = s.filter(function (e) {\n        return Object.getOwnPropertyDescriptor(t, e).enumerable;\n      })), i.push.apply(i, s);\n    }\n\n    return i;\n  }\n\n  function o(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i = null != arguments[e] ? arguments[e] : {};\n      e % 2 ? n(Object(i), !0).forEach(function (e) {\n        s(t, e, i[e]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : n(Object(i)).forEach(function (e) {\n        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n      });\n    }\n\n    return t;\n  }\n\n  function l(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n      constructor: {\n        value: t,\n        writable: !0,\n        configurable: !0\n      }\n    }), e && a(t, e);\n  }\n\n  function r(t) {\n    return (r = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    })(t);\n  }\n\n  function a(t, e) {\n    return (a = Object.setPrototypeOf || function (t, e) {\n      return t.__proto__ = e, t;\n    })(t, e);\n  }\n\n  function c(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n\n  function h(t, e) {\n    return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? c(t) : e;\n  }\n\n  function d(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          s = r(t);\n\n      if (e) {\n        var n = r(this).constructor;\n        i = Reflect.construct(s, arguments, n);\n      } else i = s.apply(this, arguments);\n\n      return h(this, i);\n    };\n  }\n\n  function u(t, e, i) {\n    return (u = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, i) {\n      var s = function (t, e) {\n        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = r(t));) {\n          ;\n        }\n\n        return t;\n      }(t, e);\n\n      if (s) {\n        var n = Object.getOwnPropertyDescriptor(s, e);\n        return n.get ? n.get.call(i) : n.value;\n      }\n    })(t, e, i || t);\n  }\n\n  function f(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(t))) return;\n      var i = [],\n          s = !0,\n          n = !1,\n          o = void 0;\n\n      try {\n        for (var l, r = t[Symbol.iterator](); !(s = (l = r.next()).done) && (i.push(l.value), !e || i.length !== e); s = !0) {\n          ;\n        }\n      } catch (t) {\n        n = !0, o = t;\n      } finally {\n        try {\n          s || null == r[\"return\"] || r[\"return\"]();\n        } finally {\n          if (n) throw o;\n        }\n      }\n\n      return i;\n    }(t, e) || m(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function p(t) {\n    return function (t) {\n      if (Array.isArray(t)) return v(t);\n    }(t) || function (t) {\n      if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t);\n    }(t) || m(t) || function () {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function m(t, e) {\n    if (t) {\n      if (\"string\" == typeof t) return v(t, e);\n      var i = Object.prototype.toString.call(t).slice(8, -1);\n      return \"Object\" === i && t.constructor && (i = t.constructor.name), \"Map\" === i || \"Set\" === i ? Array.from(t) : \"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? v(t, e) : void 0;\n    }\n  }\n\n  function v(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, s = new Array(e); i < e; i++) {\n      s[i] = t[i];\n    }\n\n    return s;\n  }\n\n  var y = {\n    el: document,\n    name: \"scroll\",\n    offset: [0, 0],\n    repeat: !1,\n    smooth: !1,\n    initPosition: {\n      x: 0,\n      y: 0\n    },\n    direction: \"vertical\",\n    gestureDirection: \"vertical\",\n    reloadOnContextChange: !1,\n    lerp: .1,\n    \"class\": \"is-inview\",\n    scrollbarContainer: !1,\n    scrollbarClass: \"c-scrollbar\",\n    scrollingClass: \"has-scroll-scrolling\",\n    draggingClass: \"has-scroll-dragging\",\n    smoothClass: \"has-scroll-smooth\",\n    initClass: \"has-scroll-init\",\n    getSpeed: !1,\n    getDirection: !1,\n    scrollFromAnywhere: !1,\n    multiplier: 1,\n    firefoxMultiplier: 50,\n    touchMultiplier: 2,\n    resetNativeScroll: !0,\n    tablet: {\n      smooth: !1,\n      direction: \"vertical\",\n      gestureDirection: \"vertical\",\n      breakpoint: 1024\n    },\n    smartphone: {\n      smooth: !1,\n      direction: \"vertical\",\n      gestureDirection: \"vertical\"\n    }\n  },\n      b = function () {\n    function e() {\n      var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      t(this, e), Object.assign(this, y, i), this.smartphone = y.smartphone, i.smartphone && Object.assign(this.smartphone, i.smartphone), this.tablet = y.tablet, i.tablet && Object.assign(this.tablet, i.tablet), this.namespace = \"locomotive\", this.html = document.documentElement, this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.windowMiddle = {\n        x: this.windowWidth / 2,\n        y: this.windowHeight / 2\n      }, this.els = {}, this.currentElements = {}, this.listeners = {}, this.hasScrollTicking = !1, this.hasCallEventSet = !1, this.checkScroll = this.checkScroll.bind(this), this.checkResize = this.checkResize.bind(this), this.checkEvent = this.checkEvent.bind(this), this.instance = {\n        scroll: {\n          x: 0,\n          y: 0\n        },\n        limit: {\n          x: this.html.offsetWidth,\n          y: this.html.offsetHeight\n        },\n        currentElements: this.currentElements\n      }, this.isMobile ? this.isTablet ? this.context = \"tablet\" : this.context = \"smartphone\" : this.context = \"desktop\", this.isMobile && (this.direction = this[this.context].direction), \"horizontal\" === this.direction ? this.directionAxis = \"x\" : this.directionAxis = \"y\", this.getDirection && (this.instance.direction = null), this.getDirection && (this.instance.speed = 0), this.html.classList.add(this.initClass), window.addEventListener(\"resize\", this.checkResize, !1);\n    }\n\n    return i(e, [{\n      key: \"init\",\n      value: function value() {\n        this.initEvents();\n      }\n    }, {\n      key: \"checkScroll\",\n      value: function value() {\n        this.dispatchScroll();\n      }\n    }, {\n      key: \"checkResize\",\n      value: function value() {\n        var t = this;\n        this.resizeTick || (this.resizeTick = !0, requestAnimationFrame(function () {\n          t.resize(), t.resizeTick = !1;\n        }));\n      }\n    }, {\n      key: \"resize\",\n      value: function value() {}\n    }, {\n      key: \"checkContext\",\n      value: function value() {\n        if (this.reloadOnContextChange) {\n          this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || \"MacIntel\" === navigator.platform && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint, this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;\n          var t = this.context;\n          if (this.isMobile ? this.isTablet ? this.context = \"tablet\" : this.context = \"smartphone\" : this.context = \"desktop\", t != this.context) (\"desktop\" == t ? this.smooth : this[t].smooth) != (\"desktop\" == this.context ? this.smooth : this[this.context].smooth) && window.location.reload();\n        }\n      }\n    }, {\n      key: \"initEvents\",\n      value: function value() {\n        var t = this;\n        this.scrollToEls = this.el.querySelectorAll(\"[data-\".concat(this.name, \"-to]\")), this.setScrollTo = this.setScrollTo.bind(this), this.scrollToEls.forEach(function (e) {\n          e.addEventListener(\"click\", t.setScrollTo, !1);\n        });\n      }\n    }, {\n      key: \"setScrollTo\",\n      value: function value(t) {\n        t.preventDefault(), this.scrollTo(t.currentTarget.getAttribute(\"data-\".concat(this.name, \"-href\")) || t.currentTarget.getAttribute(\"href\"), {\n          offset: t.currentTarget.getAttribute(\"data-\".concat(this.name, \"-offset\"))\n        });\n      }\n    }, {\n      key: \"addElements\",\n      value: function value() {}\n    }, {\n      key: \"detectElements\",\n      value: function value(t) {\n        var e = this,\n            i = this.instance.scroll.y,\n            s = i + this.windowHeight,\n            n = this.instance.scroll.x,\n            o = n + this.windowWidth;\n        Object.entries(this.els).forEach(function (l) {\n          var r = f(l, 2),\n              a = r[0],\n              c = r[1];\n          if (!c || c.inView && !t || (\"horizontal\" === e.direction ? o >= c.left && n < c.right && e.setInView(c, a) : s >= c.top && i < c.bottom && e.setInView(c, a)), c && c.inView) if (\"horizontal\" === e.direction) {\n            var h = c.right - c.left;\n            c.progress = (e.instance.scroll.x - (c.left - e.windowWidth)) / (h + e.windowWidth), (o < c.left || n > c.right) && e.setOutOfView(c, a);\n          } else {\n            var d = c.bottom - c.top;\n            c.progress = (e.instance.scroll.y - (c.top - e.windowHeight)) / (d + e.windowHeight), (s < c.top || i > c.bottom) && e.setOutOfView(c, a);\n          }\n        }), this.hasScrollTicking = !1;\n      }\n    }, {\n      key: \"setInView\",\n      value: function value(t, e) {\n        this.els[e].inView = !0, t.el.classList.add(t[\"class\"]), this.currentElements[e] = t, t.call && this.hasCallEventSet && (this.dispatchCall(t, \"enter\"), t.repeat || (this.els[e].call = !1));\n      }\n    }, {\n      key: \"setOutOfView\",\n      value: function value(t, e) {\n        var i = this;\n        this.els[e].inView = !1, Object.keys(this.currentElements).forEach(function (t) {\n          t === e && delete i.currentElements[t];\n        }), t.call && this.hasCallEventSet && this.dispatchCall(t, \"exit\"), t.repeat && t.el.classList.remove(t[\"class\"]);\n      }\n    }, {\n      key: \"dispatchCall\",\n      value: function value(t, e) {\n        this.callWay = e, this.callValue = t.call.split(\",\").map(function (t) {\n          return t.trim();\n        }), this.callObj = t, 1 == this.callValue.length && (this.callValue = this.callValue[0]);\n        var i = new Event(this.namespace + \"call\");\n        this.el.dispatchEvent(i);\n      }\n    }, {\n      key: \"dispatchScroll\",\n      value: function value() {\n        var t = new Event(this.namespace + \"scroll\");\n        this.el.dispatchEvent(t);\n      }\n    }, {\n      key: \"setEvents\",\n      value: function value(t, e) {\n        this.listeners[t] || (this.listeners[t] = []);\n        var i = this.listeners[t];\n        i.push(e), 1 === i.length && this.el.addEventListener(this.namespace + t, this.checkEvent, !1), \"call\" === t && (this.hasCallEventSet = !0, this.detectElements(!0));\n      }\n    }, {\n      key: \"unsetEvents\",\n      value: function value(t, e) {\n        if (this.listeners[t]) {\n          var i = this.listeners[t],\n              s = i.indexOf(e);\n          s < 0 || (i.splice(s, 1), 0 === i.index && this.el.removeEventListener(this.namespace + t, this.checkEvent, !1));\n        }\n      }\n    }, {\n      key: \"checkEvent\",\n      value: function value(t) {\n        var e = this,\n            i = t.type.replace(this.namespace, \"\"),\n            s = this.listeners[i];\n        s && 0 !== s.length && s.forEach(function (t) {\n          switch (i) {\n            case \"scroll\":\n              return t(e.instance);\n\n            case \"call\":\n              return t(e.callValue, e.callWay, e.callObj);\n\n            default:\n              return t();\n          }\n        });\n      }\n    }, {\n      key: \"startScroll\",\n      value: function value() {}\n    }, {\n      key: \"stopScroll\",\n      value: function value() {}\n    }, {\n      key: \"setScroll\",\n      value: function value(t, e) {\n        this.instance.scroll = {\n          x: 0,\n          y: 0\n        };\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        var t = this;\n        window.removeEventListener(\"resize\", this.checkResize, !1), Object.keys(this.listeners).forEach(function (e) {\n          t.el.removeEventListener(t.namespace + e, t.checkEvent, !1);\n        }), this.listeners = {}, this.scrollToEls.forEach(function (e) {\n          e.removeEventListener(\"click\", t.setScrollTo, !1);\n        }), this.html.classList.remove(this.initClass);\n      }\n    }]), e;\n  }(),\n      g = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof __webpack_require__.g ? __webpack_require__.g : \"undefined\" != typeof self ? self : {};\n\n  function w(t, e) {\n    return t(e = {\n      exports: {}\n    }, e.exports), e.exports;\n  }\n\n  var S = w(function (t, e) {\n    t.exports = {\n      polyfill: function polyfill() {\n        var t = window,\n            e = document;\n\n        if (!(\"scrollBehavior\" in e.documentElement.style) || !0 === t.__forceSmoothScrollPolyfill__) {\n          var i,\n              s = t.HTMLElement || t.Element,\n              n = {\n            scroll: t.scroll || t.scrollTo,\n            scrollBy: t.scrollBy,\n            elementScroll: s.prototype.scroll || r,\n            scrollIntoView: s.prototype.scrollIntoView\n          },\n              o = t.performance && t.performance.now ? t.performance.now.bind(t.performance) : Date.now,\n              l = (i = t.navigator.userAgent, new RegExp([\"MSIE \", \"Trident/\", \"Edge/\"].join(\"|\")).test(i) ? 1 : 0);\n          t.scroll = t.scrollTo = function () {\n            void 0 !== arguments[0] && (!0 !== a(arguments[0]) ? p.call(t, e.body, void 0 !== arguments[0].left ? ~~arguments[0].left : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? ~~arguments[0].top : t.scrollY || t.pageYOffset) : n.scroll.call(t, void 0 !== arguments[0].left ? arguments[0].left : \"object\" != _typeof(arguments[0]) ? arguments[0] : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : t.scrollY || t.pageYOffset));\n          }, t.scrollBy = function () {\n            void 0 !== arguments[0] && (a(arguments[0]) ? n.scrollBy.call(t, void 0 !== arguments[0].left ? arguments[0].left : \"object\" != _typeof(arguments[0]) ? arguments[0] : 0, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : 0) : p.call(t, e.body, ~~arguments[0].left + (t.scrollX || t.pageXOffset), ~~arguments[0].top + (t.scrollY || t.pageYOffset)));\n          }, s.prototype.scroll = s.prototype.scrollTo = function () {\n            if (void 0 !== arguments[0]) if (!0 !== a(arguments[0])) {\n              var t = arguments[0].left,\n                  e = arguments[0].top;\n              p.call(this, this, void 0 === t ? this.scrollLeft : ~~t, void 0 === e ? this.scrollTop : ~~e);\n            } else {\n              if (\"number\" == typeof arguments[0] && void 0 === arguments[1]) throw new SyntaxError(\"Value could not be converted\");\n              n.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left : \"object\" != _typeof(arguments[0]) ? ~~arguments[0] : this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top : void 0 !== arguments[1] ? ~~arguments[1] : this.scrollTop);\n            }\n          }, s.prototype.scrollBy = function () {\n            void 0 !== arguments[0] && (!0 !== a(arguments[0]) ? this.scroll({\n              left: ~~arguments[0].left + this.scrollLeft,\n              top: ~~arguments[0].top + this.scrollTop,\n              behavior: arguments[0].behavior\n            }) : n.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop));\n          }, s.prototype.scrollIntoView = function () {\n            if (!0 !== a(arguments[0])) {\n              var i = u(this),\n                  s = i.getBoundingClientRect(),\n                  o = this.getBoundingClientRect();\n              i !== e.body ? (p.call(this, i, i.scrollLeft + o.left - s.left, i.scrollTop + o.top - s.top), \"fixed\" !== t.getComputedStyle(i).position && t.scrollBy({\n                left: s.left,\n                top: s.top,\n                behavior: \"smooth\"\n              })) : t.scrollBy({\n                left: o.left,\n                top: o.top,\n                behavior: \"smooth\"\n              });\n            } else n.scrollIntoView.call(this, void 0 === arguments[0] || arguments[0]);\n          };\n        }\n\n        function r(t, e) {\n          this.scrollLeft = t, this.scrollTop = e;\n        }\n\n        function a(t) {\n          if (null === t || \"object\" != _typeof(t) || void 0 === t.behavior || \"auto\" === t.behavior || \"instant\" === t.behavior) return !0;\n          if (\"object\" == _typeof(t) && \"smooth\" === t.behavior) return !1;\n          throw new TypeError(\"behavior member of ScrollOptions \" + t.behavior + \" is not a valid value for enumeration ScrollBehavior.\");\n        }\n\n        function c(t, e) {\n          return \"Y\" === e ? t.clientHeight + l < t.scrollHeight : \"X\" === e ? t.clientWidth + l < t.scrollWidth : void 0;\n        }\n\n        function h(e, i) {\n          var s = t.getComputedStyle(e, null)[\"overflow\" + i];\n          return \"auto\" === s || \"scroll\" === s;\n        }\n\n        function d(t) {\n          var e = c(t, \"Y\") && h(t, \"Y\"),\n              i = c(t, \"X\") && h(t, \"X\");\n          return e || i;\n        }\n\n        function u(t) {\n          for (; t !== e.body && !1 === d(t);) {\n            t = t.parentNode || t.host;\n          }\n\n          return t;\n        }\n\n        function f(e) {\n          var i,\n              s,\n              n,\n              l,\n              r = (o() - e.startTime) / 468;\n          l = r = r > 1 ? 1 : r, i = .5 * (1 - Math.cos(Math.PI * l)), s = e.startX + (e.x - e.startX) * i, n = e.startY + (e.y - e.startY) * i, e.method.call(e.scrollable, s, n), s === e.x && n === e.y || t.requestAnimationFrame(f.bind(t, e));\n        }\n\n        function p(i, s, l) {\n          var a,\n              c,\n              h,\n              d,\n              u = o();\n          i === e.body ? (a = t, c = t.scrollX || t.pageXOffset, h = t.scrollY || t.pageYOffset, d = n.scroll) : (a = i, c = i.scrollLeft, h = i.scrollTop, d = r), f({\n            scrollable: a,\n            method: d,\n            startTime: u,\n            startX: c,\n            startY: h,\n            x: s,\n            y: l\n          });\n        }\n      }\n    };\n  }),\n      x = (S.polyfill, function (e) {\n    l(n, e);\n    var s = d(n);\n\n    function n() {\n      var e,\n          i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      return t(this, n), (e = s.call(this, i)).resetNativeScroll && (history.scrollRestoration && (history.scrollRestoration = \"manual\"), window.scrollTo(0, 0)), window.addEventListener(\"scroll\", e.checkScroll, !1), void 0 === window.smoothscrollPolyfill && (window.smoothscrollPolyfill = S, window.smoothscrollPolyfill.polyfill()), e;\n    }\n\n    return i(n, [{\n      key: \"init\",\n      value: function value() {\n        this.instance.scroll.y = window.pageYOffset, this.addElements(), this.detectElements(), u(r(n.prototype), \"init\", this).call(this);\n      }\n    }, {\n      key: \"checkScroll\",\n      value: function value() {\n        var t = this;\n        u(r(n.prototype), \"checkScroll\", this).call(this), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.instance.scroll.y = window.pageYOffset, Object.entries(this.els).length && (this.hasScrollTicking || (requestAnimationFrame(function () {\n          t.detectElements();\n        }), this.hasScrollTicking = !0));\n      }\n    }, {\n      key: \"addDirection\",\n      value: function value() {\n        window.pageYOffset > this.instance.scroll.y ? \"down\" !== this.instance.direction && (this.instance.direction = \"down\") : window.pageYOffset < this.instance.scroll.y && \"up\" !== this.instance.direction && (this.instance.direction = \"up\");\n      }\n    }, {\n      key: \"addSpeed\",\n      value: function value() {\n        window.pageYOffset != this.instance.scroll.y ? this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0;\n      }\n    }, {\n      key: \"resize\",\n      value: function value() {\n        Object.entries(this.els).length && (this.windowHeight = window.innerHeight, this.updateElements());\n      }\n    }, {\n      key: \"addElements\",\n      value: function value() {\n        var t = this;\n        this.els = {}, this.el.querySelectorAll(\"[data-\" + this.name + \"]\").forEach(function (e, i) {\n          e.getBoundingClientRect();\n          var s,\n              n,\n              o,\n              l = e.dataset[t.name + \"Class\"] || t[\"class\"],\n              r = \"string\" == typeof e.dataset[t.name + \"Id\"] ? e.dataset[t.name + \"Id\"] : i,\n              a = \"string\" == typeof e.dataset[t.name + \"Offset\"] ? e.dataset[t.name + \"Offset\"].split(\",\") : t.offset,\n              c = e.dataset[t.name + \"Repeat\"],\n              h = e.dataset[t.name + \"Call\"],\n              d = e.dataset[t.name + \"Target\"],\n              u = (o = void 0 !== d ? document.querySelector(\"\".concat(d)) : e).getBoundingClientRect();\n          s = u.top + t.instance.scroll.y, n = u.left + t.instance.scroll.x;\n          var f = s + o.offsetHeight,\n              p = n + o.offsetWidth;\n          c = \"false\" != c && (null != c || t.repeat);\n          var m = t.getRelativeOffset(a),\n              v = {\n            el: e,\n            targetEl: o,\n            id: r,\n            \"class\": l,\n            top: s += m[0],\n            bottom: f -= m[1],\n            left: n,\n            right: p,\n            offset: a,\n            progress: 0,\n            repeat: c,\n            inView: !1,\n            call: h\n          };\n          t.els[r] = v, e.classList.contains(l) && t.setInView(t.els[r], r);\n        });\n      }\n    }, {\n      key: \"updateElements\",\n      value: function value() {\n        var t = this;\n        Object.entries(this.els).forEach(function (e) {\n          var i = f(e, 2),\n              s = i[0],\n              n = i[1],\n              o = n.targetEl.getBoundingClientRect().top + t.instance.scroll.y,\n              l = o + n.targetEl.offsetHeight,\n              r = t.getRelativeOffset(n.offset);\n          t.els[s].top = o + r[0], t.els[s].bottom = l - r[1];\n        }), this.hasScrollTicking = !1;\n      }\n    }, {\n      key: \"getRelativeOffset\",\n      value: function value(t) {\n        var e = [0, 0];\n        if (t) for (var i = 0; i < t.length; i++) {\n          \"string\" == typeof t[i] ? t[i].includes(\"%\") ? e[i] = parseInt(t[i].replace(\"%\", \"\") * this.windowHeight / 100) : e[i] = parseInt(t[i]) : e[i] = t[i];\n        }\n        return e;\n      }\n    }, {\n      key: \"scrollTo\",\n      value: function value(t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n            i = parseInt(e.offset) || 0,\n            s = !!e.callback && e.callback;\n\n        if (\"string\" == typeof t) {\n          if (\"top\" === t) t = this.html;else if (\"bottom\" === t) t = this.html.offsetHeight - window.innerHeight;else if (!(t = document.querySelector(t))) return;\n        } else if (\"number\" == typeof t) t = parseInt(t);else if (!t || !t.tagName) return void console.warn(\"`target` parameter is not valid\");\n\n        i = \"number\" != typeof t ? t.getBoundingClientRect().top + i + this.instance.scroll.y : t + i;\n\n        var n = function n() {\n          return parseInt(window.pageYOffset) === parseInt(i);\n        };\n\n        if (s) {\n          if (n()) return void s();\n\n          var o = function t() {\n            n() && (window.removeEventListener(\"scroll\", t), s());\n          };\n\n          window.addEventListener(\"scroll\", o);\n        }\n\n        window.scrollTo({\n          top: i,\n          behavior: 0 === e.duration ? \"auto\" : \"smooth\"\n        });\n      }\n    }, {\n      key: \"update\",\n      value: function value() {\n        this.addElements(), this.detectElements();\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        u(r(n.prototype), \"destroy\", this).call(this), window.removeEventListener(\"scroll\", this.checkScroll, !1);\n      }\n    }]), n;\n  }(b)),\n      k = Object.getOwnPropertySymbols,\n      T = Object.prototype.hasOwnProperty,\n      E = Object.prototype.propertyIsEnumerable;\n\n  function A(t) {\n    if (null == t) throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n    return Object(t);\n  }\n\n  var O = function () {\n    try {\n      if (!Object.assign) return !1;\n      var t = new String(\"abc\");\n      if (t[5] = \"de\", \"5\" === Object.getOwnPropertyNames(t)[0]) return !1;\n\n      for (var e = {}, i = 0; i < 10; i++) {\n        e[\"_\" + String.fromCharCode(i)] = i;\n      }\n\n      if (\"0123456789\" !== Object.getOwnPropertyNames(e).map(function (t) {\n        return e[t];\n      }).join(\"\")) return !1;\n      var s = {};\n      return \"abcdefghijklmnopqrst\".split(\"\").forEach(function (t) {\n        s[t] = t;\n      }), \"abcdefghijklmnopqrst\" === Object.keys(Object.assign({}, s)).join(\"\");\n    } catch (t) {\n      return !1;\n    }\n  }() ? Object.assign : function (t, e) {\n    for (var i, s, n = A(t), o = 1; o < arguments.length; o++) {\n      for (var l in i = Object(arguments[o])) {\n        T.call(i, l) && (n[l] = i[l]);\n      }\n\n      if (k) {\n        s = k(i);\n\n        for (var r = 0; r < s.length; r++) {\n          E.call(i, s[r]) && (n[s[r]] = i[s[r]]);\n        }\n      }\n    }\n\n    return n;\n  };\n\n  function D() {}\n\n  D.prototype = {\n    on: function on(t, e, i) {\n      var s = this.e || (this.e = {});\n      return (s[t] || (s[t] = [])).push({\n        fn: e,\n        ctx: i\n      }), this;\n    },\n    once: function once(t, e, i) {\n      var s = this;\n\n      function n() {\n        s.off(t, n), e.apply(i, arguments);\n      }\n\n      return n._ = e, this.on(t, n, i);\n    },\n    emit: function emit(t) {\n      for (var e = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[t] || []).slice(), s = 0, n = i.length; s < n; s++) {\n        i[s].fn.apply(i[s].ctx, e);\n      }\n\n      return this;\n    },\n    off: function off(t, e) {\n      var i = this.e || (this.e = {}),\n          s = i[t],\n          n = [];\n      if (s && e) for (var o = 0, l = s.length; o < l; o++) {\n        s[o].fn !== e && s[o].fn._ !== e && n.push(s[o]);\n      }\n      return n.length ? i[t] = n : delete i[t], this;\n    }\n  };\n  var C = D,\n      L = w(function (t, e) {\n    (function () {\n      (null !== e ? e : this).Lethargy = function () {\n        function t(t, e, i, s) {\n          this.stability = null != t ? Math.abs(t) : 8, this.sensitivity = null != e ? 1 + Math.abs(e) : 100, this.tolerance = null != i ? 1 + Math.abs(i) : 1.1, this.delay = null != s ? s : 150, this.lastUpDeltas = function () {\n            var t, e, i;\n\n            for (i = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) {\n              i.push(null);\n            }\n\n            return i;\n          }.call(this), this.lastDownDeltas = function () {\n            var t, e, i;\n\n            for (i = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) {\n              i.push(null);\n            }\n\n            return i;\n          }.call(this), this.deltasTimestamp = function () {\n            var t, e, i;\n\n            for (i = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) {\n              i.push(null);\n            }\n\n            return i;\n          }.call(this);\n        }\n\n        return t.prototype.check = function (t) {\n          var e;\n          return null != (t = t.originalEvent || t).wheelDelta ? e = t.wheelDelta : null != t.deltaY ? e = -40 * t.deltaY : null == t.detail && 0 !== t.detail || (e = -40 * t.detail), this.deltasTimestamp.push(Date.now()), this.deltasTimestamp.shift(), e > 0 ? (this.lastUpDeltas.push(e), this.lastUpDeltas.shift(), this.isInertia(1)) : (this.lastDownDeltas.push(e), this.lastDownDeltas.shift(), this.isInertia(-1));\n        }, t.prototype.isInertia = function (t) {\n          var e, i, s, n, o, l, r;\n          return null === (e = -1 === t ? this.lastDownDeltas : this.lastUpDeltas)[0] ? t : !(this.deltasTimestamp[2 * this.stability - 2] + this.delay > Date.now() && e[0] === e[2 * this.stability - 1]) && (s = e.slice(0, this.stability), i = e.slice(this.stability, 2 * this.stability), r = s.reduce(function (t, e) {\n            return t + e;\n          }), o = i.reduce(function (t, e) {\n            return t + e;\n          }), l = r / s.length, n = o / i.length, Math.abs(l) < Math.abs(n * this.tolerance) && this.sensitivity < Math.abs(n) && t);\n        }, t.prototype.showLastUpDeltas = function () {\n          return this.lastUpDeltas;\n        }, t.prototype.showLastDownDeltas = function () {\n          return this.lastDownDeltas;\n        }, t;\n      }();\n    }).call(g);\n  }),\n      M = {\n    hasWheelEvent: \"onwheel\" in document,\n    hasMouseWheelEvent: \"onmousewheel\" in document,\n    hasTouch: \"ontouchstart\" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,\n    hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,\n    hasPointer: !!window.navigator.msPointerEnabled,\n    hasKeyDown: \"onkeydown\" in document,\n    isFirefox: navigator.userAgent.indexOf(\"Firefox\") > -1\n  },\n      j = Object.prototype.toString,\n      _ = Object.prototype.hasOwnProperty;\n\n  function B(t, e) {\n    return function () {\n      return t.apply(e, arguments);\n    };\n  }\n\n  var W = L.Lethargy,\n      H = \"virtualscroll\",\n      R = V,\n      P = 37,\n      Y = 38,\n      I = 39,\n      z = 40,\n      X = 32;\n\n  function V(t) {\n    !function (t) {\n      if (!t) return console.warn(\"bindAll requires at least one argument.\");\n      var e = Array.prototype.slice.call(arguments, 1);\n      if (0 === e.length) for (var i in t) {\n        _.call(t, i) && \"function\" == typeof t[i] && \"[object Function]\" == j.call(t[i]) && e.push(i);\n      }\n\n      for (var s = 0; s < e.length; s++) {\n        var n = e[s];\n        t[n] = B(t[n], t);\n      }\n    }(this, \"_onWheel\", \"_onMouseWheel\", \"_onTouchStart\", \"_onTouchMove\", \"_onKeyDown\"), this.el = window, t && t.el && (this.el = t.el, delete t.el), this.options = O({\n      mouseMultiplier: 1,\n      touchMultiplier: 2,\n      firefoxMultiplier: 15,\n      keyStep: 120,\n      preventTouch: !1,\n      unpreventTouchClass: \"vs-touchmove-allowed\",\n      limitInertia: !1,\n      useKeyboard: !0,\n      useTouch: !0\n    }, t), this.options.limitInertia && (this._lethargy = new W()), this._emitter = new C(), this._event = {\n      y: 0,\n      x: 0,\n      deltaX: 0,\n      deltaY: 0\n    }, this.touchStartX = null, this.touchStartY = null, this.bodyTouchAction = null, void 0 !== this.options.passive && (this.listenerOptions = {\n      passive: this.options.passive\n    });\n  }\n\n  function F(t, e, i) {\n    return (1 - i) * t + i * e;\n  }\n\n  function q(t) {\n    var e = {};\n\n    if (window.getComputedStyle) {\n      var i = getComputedStyle(t),\n          s = i.transform || i.webkitTransform || i.mozTransform,\n          n = s.match(/^matrix3d\\((.+)\\)$/);\n      return n ? (e.x = n ? parseFloat(n[1].split(\", \")[12]) : 0, e.y = n ? parseFloat(n[1].split(\", \")[13]) : 0) : (n = s.match(/^matrix\\((.+)\\)$/), e.x = n ? parseFloat(n[1].split(\", \")[4]) : 0, e.y = n ? parseFloat(n[1].split(\", \")[5]) : 0), e;\n    }\n  }\n\n  function K(t) {\n    for (var e = []; t && t !== document; t = t.parentNode) {\n      e.push(t);\n    }\n\n    return e;\n  }\n\n  V.prototype._notify = function (t) {\n    var e = this._event;\n    e.x += e.deltaX, e.y += e.deltaY, this._emitter.emit(H, {\n      x: e.x,\n      y: e.y,\n      deltaX: e.deltaX,\n      deltaY: e.deltaY,\n      originalEvent: t\n    });\n  }, V.prototype._onWheel = function (t) {\n    var e = this.options;\n\n    if (!this._lethargy || !1 !== this._lethargy.check(t)) {\n      var i = this._event;\n      i.deltaX = t.wheelDeltaX || -1 * t.deltaX, i.deltaY = t.wheelDeltaY || -1 * t.deltaY, M.isFirefox && 1 == t.deltaMode && (i.deltaX *= e.firefoxMultiplier, i.deltaY *= e.firefoxMultiplier), i.deltaX *= e.mouseMultiplier, i.deltaY *= e.mouseMultiplier, this._notify(t);\n    }\n  }, V.prototype._onMouseWheel = function (t) {\n    if (!this.options.limitInertia || !1 !== this._lethargy.check(t)) {\n      var e = this._event;\n      e.deltaX = t.wheelDeltaX ? t.wheelDeltaX : 0, e.deltaY = t.wheelDeltaY ? t.wheelDeltaY : t.wheelDelta, this._notify(t);\n    }\n  }, V.prototype._onTouchStart = function (t) {\n    var e = t.targetTouches ? t.targetTouches[0] : t;\n    this.touchStartX = e.pageX, this.touchStartY = e.pageY;\n  }, V.prototype._onTouchMove = function (t) {\n    var e = this.options;\n    e.preventTouch && !t.target.classList.contains(e.unpreventTouchClass) && t.preventDefault();\n    var i = this._event,\n        s = t.targetTouches ? t.targetTouches[0] : t;\n    i.deltaX = (s.pageX - this.touchStartX) * e.touchMultiplier, i.deltaY = (s.pageY - this.touchStartY) * e.touchMultiplier, this.touchStartX = s.pageX, this.touchStartY = s.pageY, this._notify(t);\n  }, V.prototype._onKeyDown = function (t) {\n    var e = this._event;\n    e.deltaX = e.deltaY = 0;\n    var i = window.innerHeight - 40;\n\n    switch (t.keyCode) {\n      case P:\n      case Y:\n        e.deltaY = this.options.keyStep;\n        break;\n\n      case I:\n      case z:\n        e.deltaY = -this.options.keyStep;\n        break;\n\n      case t.shiftKey:\n        e.deltaY = i;\n        break;\n\n      case X:\n        e.deltaY = -i;\n        break;\n\n      default:\n        return;\n    }\n\n    this._notify(t);\n  }, V.prototype._bind = function () {\n    M.hasWheelEvent && this.el.addEventListener(\"wheel\", this._onWheel, this.listenerOptions), M.hasMouseWheelEvent && this.el.addEventListener(\"mousewheel\", this._onMouseWheel, this.listenerOptions), M.hasTouch && this.options.useTouch && (this.el.addEventListener(\"touchstart\", this._onTouchStart, this.listenerOptions), this.el.addEventListener(\"touchmove\", this._onTouchMove, this.listenerOptions)), M.hasPointer && M.hasTouchWin && (this.bodyTouchAction = document.body.style.msTouchAction, document.body.style.msTouchAction = \"none\", this.el.addEventListener(\"MSPointerDown\", this._onTouchStart, !0), this.el.addEventListener(\"MSPointerMove\", this._onTouchMove, !0)), M.hasKeyDown && this.options.useKeyboard && document.addEventListener(\"keydown\", this._onKeyDown);\n  }, V.prototype._unbind = function () {\n    M.hasWheelEvent && this.el.removeEventListener(\"wheel\", this._onWheel), M.hasMouseWheelEvent && this.el.removeEventListener(\"mousewheel\", this._onMouseWheel), M.hasTouch && (this.el.removeEventListener(\"touchstart\", this._onTouchStart), this.el.removeEventListener(\"touchmove\", this._onTouchMove)), M.hasPointer && M.hasTouchWin && (document.body.style.msTouchAction = this.bodyTouchAction, this.el.removeEventListener(\"MSPointerDown\", this._onTouchStart, !0), this.el.removeEventListener(\"MSPointerMove\", this._onTouchMove, !0)), M.hasKeyDown && this.options.useKeyboard && document.removeEventListener(\"keydown\", this._onKeyDown);\n  }, V.prototype.on = function (t, e) {\n    this._emitter.on(H, t, e);\n\n    var i = this._emitter.e;\n    i && i[H] && 1 === i[H].length && this._bind();\n  }, V.prototype.off = function (t, e) {\n    this._emitter.off(H, t, e);\n\n    var i = this._emitter.e;\n    (!i[H] || i[H].length <= 0) && this._unbind();\n  }, V.prototype.reset = function () {\n    var t = this._event;\n    t.x = 0, t.y = 0;\n  }, V.prototype.destroy = function () {\n    this._emitter.off(), this._unbind();\n  };\n  var N = \"function\" == typeof Float32Array;\n\n  function U(t, e) {\n    return 1 - 3 * e + 3 * t;\n  }\n\n  function $(t, e) {\n    return 3 * e - 6 * t;\n  }\n\n  function G(t) {\n    return 3 * t;\n  }\n\n  function J(t, e, i) {\n    return ((U(e, i) * t + $(e, i)) * t + G(e)) * t;\n  }\n\n  function Q(t, e, i) {\n    return 3 * U(e, i) * t * t + 2 * $(e, i) * t + G(e);\n  }\n\n  function Z(t) {\n    return t;\n  }\n\n  var tt = function tt(t, e, i, s) {\n    if (!(0 <= t && t <= 1 && 0 <= i && i <= 1)) throw new Error(\"bezier x values must be in [0, 1] range\");\n    if (t === e && i === s) return Z;\n\n    for (var n = N ? new Float32Array(11) : new Array(11), o = 0; o < 11; ++o) {\n      n[o] = J(.1 * o, t, i);\n    }\n\n    function l(e) {\n      for (var s = 0, o = 1; 10 !== o && n[o] <= e; ++o) {\n        s += .1;\n      }\n\n      --o;\n      var l = s + .1 * ((e - n[o]) / (n[o + 1] - n[o])),\n          r = Q(l, t, i);\n      return r >= .001 ? function (t, e, i, s) {\n        for (var n = 0; n < 4; ++n) {\n          var o = Q(e, i, s);\n          if (0 === o) return e;\n          e -= (J(e, i, s) - t) / o;\n        }\n\n        return e;\n      }(e, l, t, i) : 0 === r ? l : function (t, e, i, s, n) {\n        var o,\n            l,\n            r = 0;\n\n        do {\n          (o = J(l = e + (i - e) / 2, s, n) - t) > 0 ? i = l : e = l;\n        } while (Math.abs(o) > 1e-7 && ++r < 10);\n\n        return l;\n      }(e, s, s + .1, t, i);\n    }\n\n    return function (t) {\n      return 0 === t ? 0 : 1 === t ? 1 : J(l(t), e, s);\n    };\n  },\n      et = 38,\n      it = 40,\n      st = 32,\n      nt = 9,\n      ot = 33,\n      lt = 34,\n      rt = 36,\n      at = 35,\n      ct = function (e) {\n    l(n, e);\n    var s = d(n);\n\n    function n() {\n      var e,\n          i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      return t(this, n), history.scrollRestoration && (history.scrollRestoration = \"manual\"), window.scrollTo(0, 0), (e = s.call(this, i)).inertia && (e.lerp = .1 * e.inertia), e.isScrolling = !1, e.isDraggingScrollbar = !1, e.isTicking = !1, e.hasScrollTicking = !1, e.parallaxElements = {}, e.stop = !1, e.scrollbarContainer = i.scrollbarContainer, e.checkKey = e.checkKey.bind(c(e)), window.addEventListener(\"keydown\", e.checkKey, !1), e;\n    }\n\n    return i(n, [{\n      key: \"init\",\n      value: function value() {\n        var t = this;\n        this.html.classList.add(this.smoothClass), this.html.setAttribute(\"data-\".concat(this.name, \"-direction\"), this.direction), this.instance = o({\n          delta: {\n            x: this.initPosition.x,\n            y: this.initPosition.y\n          },\n          scroll: {\n            x: this.initPosition.x,\n            y: this.initPosition.y\n          }\n        }, this.instance), this.vs = new R({\n          el: this.scrollFromAnywhere ? document : this.el,\n          mouseMultiplier: navigator.platform.indexOf(\"Win\") > -1 ? 1 : .4,\n          firefoxMultiplier: this.firefoxMultiplier,\n          touchMultiplier: this.touchMultiplier,\n          useKeyboard: !1,\n          passive: !0\n        }), this.vs.on(function (e) {\n          t.stop || t.isDraggingScrollbar || requestAnimationFrame(function () {\n            t.updateDelta(e), t.isScrolling || t.startScrolling();\n          });\n        }), this.setScrollLimit(), this.initScrollBar(), this.addSections(), this.addElements(), this.checkScroll(!0), this.transformElements(!0, !0), u(r(n.prototype), \"init\", this).call(this);\n      }\n    }, {\n      key: \"setScrollLimit\",\n      value: function value() {\n        if (this.instance.limit.y = this.el.offsetHeight - this.windowHeight, \"horizontal\" === this.direction) {\n          for (var t = 0, e = this.el.children, i = 0; i < e.length; i++) {\n            t += e[i].offsetWidth;\n          }\n\n          this.instance.limit.x = t - this.windowWidth;\n        }\n      }\n    }, {\n      key: \"startScrolling\",\n      value: function value() {\n        this.startScrollTs = Date.now(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass);\n      }\n    }, {\n      key: \"stopScrolling\",\n      value: function value() {\n        cancelAnimationFrame(this.checkScrollRaf), this.startScrollTs = void 0, this.scrollToRaf && (cancelAnimationFrame(this.scrollToRaf), this.scrollToRaf = null), this.isScrolling = !1, this.instance.scroll.y = Math.round(this.instance.scroll.y), this.html.classList.remove(this.scrollingClass);\n      }\n    }, {\n      key: \"checkKey\",\n      value: function value(t) {\n        var e = this;\n        if (this.stop) t.keyCode == nt && requestAnimationFrame(function () {\n          e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0;\n        });else {\n          switch (t.keyCode) {\n            case nt:\n              requestAnimationFrame(function () {\n                e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0, e.scrollTo(document.activeElement, {\n                  offset: -window.innerHeight / 2\n                });\n              });\n              break;\n\n            case et:\n              this.isActiveElementScrollSensitive() && (this.instance.delta[this.directionAxis] -= 240);\n              break;\n\n            case it:\n              this.isActiveElementScrollSensitive() && (this.instance.delta[this.directionAxis] += 240);\n              break;\n\n            case ot:\n              this.instance.delta[this.directionAxis] -= window.innerHeight;\n              break;\n\n            case lt:\n              this.instance.delta[this.directionAxis] += window.innerHeight;\n              break;\n\n            case rt:\n              this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];\n              break;\n\n            case at:\n              this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];\n              break;\n\n            case st:\n              this.isActiveElementScrollSensitive() && (t.shiftKey ? this.instance.delta[this.directionAxis] -= window.innerHeight : this.instance.delta[this.directionAxis] += window.innerHeight);\n              break;\n\n            default:\n              return;\n          }\n\n          this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis]), this.stopScrolling(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass);\n        }\n      }\n    }, {\n      key: \"isActiveElementScrollSensitive\",\n      value: function value() {\n        return !(document.activeElement instanceof HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement || document.activeElement instanceof HTMLButtonElement || document.activeElement instanceof HTMLSelectElement);\n      }\n    }, {\n      key: \"checkScroll\",\n      value: function value() {\n        var t = this,\n            e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n\n        if (e || this.isScrolling || this.isDraggingScrollbar) {\n          this.hasScrollTicking || (this.checkScrollRaf = requestAnimationFrame(function () {\n            return t.checkScroll();\n          }), this.hasScrollTicking = !0), this.updateScroll();\n          var i = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]),\n              s = Date.now() - this.startScrollTs;\n\n          if (!this.animatingScroll && s > 100 && (i < .5 && 0 != this.instance.delta[this.directionAxis] || i < .5 && 0 == this.instance.delta[this.directionAxis]) && this.stopScrolling(), Object.entries(this.sections).forEach(function (i) {\n            var s = f(i, 2),\n                n = (s[0], s[1]);\n            n.persistent || t.instance.scroll[t.directionAxis] > n.offset[t.directionAxis] && t.instance.scroll[t.directionAxis] < n.limit[t.directionAxis] ? (\"horizontal\" === t.direction ? t.transform(n.el, -t.instance.scroll[t.directionAxis], 0) : t.transform(n.el, 0, -t.instance.scroll[t.directionAxis]), n.inView || (n.inView = !0, n.el.style.opacity = 1, n.el.style.pointerEvents = \"all\", n.el.setAttribute(\"data-\".concat(t.name, \"-section-inview\"), \"\"))) : ((n.inView || e) && (n.inView = !1, n.el.style.opacity = 0, n.el.style.pointerEvents = \"none\", n.el.removeAttribute(\"data-\".concat(t.name, \"-section-inview\"))), t.transform(n.el, 0, 0));\n          }), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.detectElements(), this.transformElements(), this.hasScrollbar) {\n            var o = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];\n            \"horizontal\" === this.direction ? this.transform(this.scrollbarThumb, o, 0) : this.transform(this.scrollbarThumb, 0, o);\n          }\n\n          u(r(n.prototype), \"checkScroll\", this).call(this), this.hasScrollTicking = !1;\n        }\n      }\n    }, {\n      key: \"resize\",\n      value: function value() {\n        this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.checkContext(), this.windowMiddle = {\n          x: this.windowWidth / 2,\n          y: this.windowHeight / 2\n        }, this.update();\n      }\n    }, {\n      key: \"updateDelta\",\n      value: function value(t) {\n        var e,\n            i = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;\n        e = \"both\" === i ? t.deltaX + t.deltaY : \"vertical\" === i ? t.deltaY : \"horizontal\" === i ? t.deltaX : t.deltaY, this.instance.delta[this.directionAxis] -= e * this.multiplier, this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis]);\n      }\n    }, {\n      key: \"updateScroll\",\n      value: function value(t) {\n        this.isScrolling || this.isDraggingScrollbar ? this.instance.scroll[this.directionAxis] = F(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp) : this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis] ? this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]) : this.instance.scroll.y < 0 ? this.setScroll(this.instance.scroll[this.directionAxis], 0) : this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis]);\n      }\n    }, {\n      key: \"addDirection\",\n      value: function value() {\n        this.instance.delta.y > this.instance.scroll.y ? \"down\" !== this.instance.direction && (this.instance.direction = \"down\") : this.instance.delta.y < this.instance.scroll.y && \"up\" !== this.instance.direction && (this.instance.direction = \"up\"), this.instance.delta.x > this.instance.scroll.x ? \"right\" !== this.instance.direction && (this.instance.direction = \"right\") : this.instance.delta.x < this.instance.scroll.x && \"left\" !== this.instance.direction && (this.instance.direction = \"left\");\n      }\n    }, {\n      key: \"addSpeed\",\n      value: function value() {\n        this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis] ? this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0;\n      }\n    }, {\n      key: \"initScrollBar\",\n      value: function value() {\n        if (this.scrollbar = document.createElement(\"span\"), this.scrollbarThumb = document.createElement(\"span\"), this.scrollbar.classList.add(\"\".concat(this.scrollbarClass)), this.scrollbarThumb.classList.add(\"\".concat(this.scrollbarClass, \"_thumb\")), this.scrollbar.append(this.scrollbarThumb), this.scrollbarContainer ? this.scrollbarContainer.append(this.scrollbar) : document.body.append(this.scrollbar), this.getScrollBar = this.getScrollBar.bind(this), this.releaseScrollBar = this.releaseScrollBar.bind(this), this.moveScrollBar = this.moveScrollBar.bind(this), this.scrollbarThumb.addEventListener(\"mousedown\", this.getScrollBar), window.addEventListener(\"mouseup\", this.releaseScrollBar), window.addEventListener(\"mousemove\", this.moveScrollBar), this.hasScrollbar = !1, \"horizontal\" == this.direction) {\n          if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return;\n        } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;\n\n        this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, \"horizontal\" === this.direction ? this.scrollbarThumb.style.width = \"\".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), \"px\") : this.scrollbarThumb.style.height = \"\".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), \"px\"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {\n          x: this.scrollbarWidth - this.scrollbarThumbBCR.width,\n          y: this.scrollbarHeight - this.scrollbarThumbBCR.height\n        };\n      }\n    }, {\n      key: \"reinitScrollBar\",\n      value: function value() {\n        if (this.hasScrollbar = !1, \"horizontal\" == this.direction) {\n          if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return;\n        } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;\n\n        this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, \"horizontal\" === this.direction ? this.scrollbarThumb.style.width = \"\".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), \"px\") : this.scrollbarThumb.style.height = \"\".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), \"px\"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {\n          x: this.scrollbarWidth - this.scrollbarThumbBCR.width,\n          y: this.scrollbarHeight - this.scrollbarThumbBCR.height\n        };\n      }\n    }, {\n      key: \"destroyScrollBar\",\n      value: function value() {\n        this.scrollbarThumb.removeEventListener(\"mousedown\", this.getScrollBar), window.removeEventListener(\"mouseup\", this.releaseScrollBar), window.removeEventListener(\"mousemove\", this.moveScrollBar), this.scrollbar.remove();\n      }\n    }, {\n      key: \"getScrollBar\",\n      value: function value(t) {\n        this.isDraggingScrollbar = !0, this.checkScroll(), this.html.classList.remove(this.scrollingClass), this.html.classList.add(this.draggingClass);\n      }\n    }, {\n      key: \"releaseScrollBar\",\n      value: function value(t) {\n        this.isDraggingScrollbar = !1, this.isScrolling && this.html.classList.add(this.scrollingClass), this.html.classList.remove(this.draggingClass);\n      }\n    }, {\n      key: \"moveScrollBar\",\n      value: function value(t) {\n        var e = this;\n        this.isDraggingScrollbar && requestAnimationFrame(function () {\n          var i = 100 * (t.clientX - e.scrollbarBCR.left) / e.scrollbarWidth * e.instance.limit.x / 100,\n              s = 100 * (t.clientY - e.scrollbarBCR.top) / e.scrollbarHeight * e.instance.limit.y / 100;\n          s > 0 && s < e.instance.limit.y && (e.instance.delta.y = s), i > 0 && i < e.instance.limit.x && (e.instance.delta.x = i);\n        });\n      }\n    }, {\n      key: \"addElements\",\n      value: function value() {\n        var t = this;\n        this.els = {}, this.parallaxElements = {}, this.el.querySelectorAll(\"[data-\".concat(this.name, \"]\")).forEach(function (e, i) {\n          var s,\n              n,\n              o,\n              l = K(e),\n              r = Object.entries(t.sections).map(function (t) {\n            var e = f(t, 2);\n            e[0];\n            return e[1];\n          }).find(function (t) {\n            return l.includes(t.el);\n          }),\n              a = e.dataset[t.name + \"Class\"] || t[\"class\"],\n              c = \"string\" == typeof e.dataset[t.name + \"Id\"] ? e.dataset[t.name + \"Id\"] : \"el\" + i,\n              h = e.dataset[t.name + \"Repeat\"],\n              d = e.dataset[t.name + \"Call\"],\n              u = e.dataset[t.name + \"Position\"],\n              p = e.dataset[t.name + \"Delay\"],\n              m = e.dataset[t.name + \"Direction\"],\n              v = \"string\" == typeof e.dataset[t.name + \"Sticky\"],\n              y = !!e.dataset[t.name + \"Speed\"] && parseFloat(e.dataset[t.name + \"Speed\"]) / 10,\n              b = \"string\" == typeof e.dataset[t.name + \"Offset\"] ? e.dataset[t.name + \"Offset\"].split(\",\") : t.offset,\n              g = e.dataset[t.name + \"Target\"],\n              w = (o = void 0 !== g ? document.querySelector(\"\".concat(g)) : e).getBoundingClientRect();\n          null === r || r.inView ? (s = w.top + t.instance.scroll.y - q(o).y, n = w.left + t.instance.scroll.x - q(o).x) : (s = w.top - q(r.el).y - q(o).y, n = w.left - q(r.el).x - q(o).x);\n          var S = s + o.offsetHeight,\n              x = n + o.offsetWidth,\n              k = {\n            x: (x - n) / 2 + n,\n            y: (S - s) / 2 + s\n          };\n\n          if (v) {\n            var T = e.getBoundingClientRect(),\n                E = T.top,\n                A = T.left,\n                O = {\n              x: A - n,\n              y: E - s\n            };\n            s += window.innerHeight, n += window.innerWidth, S = E + o.offsetHeight - e.offsetHeight - O[t.directionAxis], k = {\n              x: ((x = A + o.offsetWidth - e.offsetWidth - O[t.directionAxis]) - n) / 2 + n,\n              y: (S - s) / 2 + s\n            };\n          }\n\n          h = \"false\" != h && (null != h || t.repeat);\n          var D = [0, 0];\n          if (b) if (\"horizontal\" === t.direction) {\n            for (var C = 0; C < b.length; C++) {\n              \"string\" == typeof b[C] ? b[C].includes(\"%\") ? D[C] = parseInt(b[C].replace(\"%\", \"\") * t.windowWidth / 100) : D[C] = parseInt(b[C]) : D[C] = b[C];\n            }\n\n            n += D[0], x -= D[1];\n          } else {\n            for (C = 0; C < b.length; C++) {\n              \"string\" == typeof b[C] ? b[C].includes(\"%\") ? D[C] = parseInt(b[C].replace(\"%\", \"\") * t.windowHeight / 100) : D[C] = parseInt(b[C]) : D[C] = b[C];\n            }\n\n            s += D[0], S -= D[1];\n          }\n          var L = {\n            el: e,\n            id: c,\n            \"class\": a,\n            section: r,\n            top: s,\n            middle: k,\n            bottom: S,\n            left: n,\n            right: x,\n            offset: b,\n            progress: 0,\n            repeat: h,\n            inView: !1,\n            call: d,\n            speed: y,\n            delay: p,\n            position: u,\n            target: o,\n            direction: m,\n            sticky: v\n          };\n          t.els[c] = L, e.classList.contains(a) && t.setInView(t.els[c], c), (!1 !== y || v) && (t.parallaxElements[c] = L);\n        });\n      }\n    }, {\n      key: \"addSections\",\n      value: function value() {\n        var t = this;\n        this.sections = {};\n        var e = this.el.querySelectorAll(\"[data-\".concat(this.name, \"-section]\"));\n        0 === e.length && (e = [this.el]), e.forEach(function (e, i) {\n          var s = \"string\" == typeof e.dataset[t.name + \"Id\"] ? e.dataset[t.name + \"Id\"] : \"section\" + i,\n              n = e.getBoundingClientRect(),\n              o = {\n            x: n.left - 1.5 * window.innerWidth - q(e).x,\n            y: n.top - 1.5 * window.innerHeight - q(e).y\n          },\n              l = {\n            x: o.x + n.width + 2 * window.innerWidth,\n            y: o.y + n.height + 2 * window.innerHeight\n          },\n              r = \"string\" == typeof e.dataset[t.name + \"Persistent\"];\n          e.setAttribute(\"data-scroll-section-id\", s);\n          var a = {\n            el: e,\n            offset: o,\n            limit: l,\n            inView: !1,\n            persistent: r,\n            id: s\n          };\n          t.sections[s] = a;\n        });\n      }\n    }, {\n      key: \"transform\",\n      value: function value(t, e, i, s) {\n        var n;\n\n        if (s) {\n          var o = q(t),\n              l = F(o.x, e, s),\n              r = F(o.y, i, s);\n          n = \"matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,\".concat(l, \",\").concat(r, \",0,1)\");\n        } else n = \"matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,\".concat(e, \",\").concat(i, \",0,1)\");\n\n        t.style.webkitTransform = n, t.style.msTransform = n, t.style.transform = n;\n      }\n    }, {\n      key: \"transformElements\",\n      value: function value(t) {\n        var e = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n            s = this.instance.scroll.x + this.windowWidth,\n            n = this.instance.scroll.y + this.windowHeight,\n            o = {\n          x: this.instance.scroll.x + this.windowMiddle.x,\n          y: this.instance.scroll.y + this.windowMiddle.y\n        };\n        Object.entries(this.parallaxElements).forEach(function (l) {\n          var r = f(l, 2),\n              a = (r[0], r[1]),\n              c = !1;\n          if (t && (c = 0), a.inView || i) switch (a.position) {\n            case \"top\":\n              c = e.instance.scroll[e.directionAxis] * -a.speed;\n              break;\n\n            case \"elementTop\":\n              c = (n - a.top) * -a.speed;\n              break;\n\n            case \"bottom\":\n              c = (e.instance.limit[e.directionAxis] - n + e.windowHeight) * a.speed;\n              break;\n\n            case \"left\":\n              c = e.instance.scroll[e.directionAxis] * -a.speed;\n              break;\n\n            case \"elementLeft\":\n              c = (s - a.left) * -a.speed;\n              break;\n\n            case \"right\":\n              c = (e.instance.limit[e.directionAxis] - s + e.windowHeight) * a.speed;\n              break;\n\n            default:\n              c = (o[e.directionAxis] - a.middle[e.directionAxis]) * -a.speed;\n          }\n          a.sticky && (c = a.inView ? \"horizontal\" === e.direction ? e.instance.scroll.x - a.left + window.innerWidth : e.instance.scroll.y - a.top + window.innerHeight : \"horizontal\" === e.direction ? e.instance.scroll.x < a.left - window.innerWidth && e.instance.scroll.x < a.left - window.innerWidth / 2 ? 0 : e.instance.scroll.x > a.right && e.instance.scroll.x > a.right + 100 && a.right - a.left + window.innerWidth : e.instance.scroll.y < a.top - window.innerHeight && e.instance.scroll.y < a.top - window.innerHeight / 2 ? 0 : e.instance.scroll.y > a.bottom && e.instance.scroll.y > a.bottom + 100 && a.bottom - a.top + window.innerHeight), !1 !== c && (\"horizontal\" === a.direction || \"horizontal\" === e.direction && \"vertical\" !== a.direction ? e.transform(a.el, c, 0, !t && a.delay) : e.transform(a.el, 0, c, !t && a.delay));\n        });\n      }\n    }, {\n      key: \"scrollTo\",\n      value: function value(t) {\n        var e = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n            s = parseInt(i.offset) || 0,\n            n = isNaN(parseInt(i.duration)) ? 1e3 : parseInt(i.duration),\n            o = i.easing || [.25, 0, .35, 1],\n            l = !!i.disableLerp,\n            r = !!i.callback && i.callback;\n\n        if (o = tt.apply(void 0, p(o)), \"string\" == typeof t) {\n          if (\"top\" === t) t = 0;else if (\"bottom\" === t) t = this.instance.limit.y;else if (\"left\" === t) t = 0;else if (\"right\" === t) t = this.instance.limit.x;else if (!(t = document.querySelector(t))) return;\n        } else if (\"number\" == typeof t) t = parseInt(t);else if (!t || !t.tagName) return void console.warn(\"`target` parameter is not valid\");\n\n        if (\"number\" != typeof t) {\n          var a = K(t).includes(this.el);\n          if (!a) return;\n          var c = t.getBoundingClientRect(),\n              h = c.top,\n              d = c.left,\n              u = K(t),\n              m = u.find(function (t) {\n            return Object.entries(e.sections).map(function (t) {\n              var e = f(t, 2);\n              e[0];\n              return e[1];\n            }).find(function (e) {\n              return e.el == t;\n            });\n          }),\n              v = 0;\n          v = m ? q(m)[this.directionAxis] : -this.instance.scroll[this.directionAxis], s = \"horizontal\" === this.direction ? d + s - v : h + s - v;\n        } else s = t + s;\n\n        var y = parseFloat(this.instance.delta[this.directionAxis]),\n            b = Math.max(0, Math.min(s, this.instance.limit[this.directionAxis])),\n            g = b - y,\n            w = function w(t) {\n          l ? \"horizontal\" === e.direction ? e.setScroll(y + g * t, e.instance.delta.y) : e.setScroll(e.instance.delta.x, y + g * t) : e.instance.delta[e.directionAxis] = y + g * t;\n        };\n\n        this.animatingScroll = !0, this.stopScrolling(), this.startScrolling();\n\n        var S = Date.now(),\n            x = function t() {\n          var i = (Date.now() - S) / n;\n          i > 1 ? (w(1), e.animatingScroll = !1, 0 == n && e.update(), r && r()) : (e.scrollToRaf = requestAnimationFrame(t), w(o(i)));\n        };\n\n        x();\n      }\n    }, {\n      key: \"update\",\n      value: function value() {\n        this.setScrollLimit(), this.addSections(), this.addElements(), this.detectElements(), this.updateScroll(), this.transformElements(!0), this.reinitScrollBar(), this.checkScroll(!0);\n      }\n    }, {\n      key: \"startScroll\",\n      value: function value() {\n        this.stop = !1;\n      }\n    }, {\n      key: \"stopScroll\",\n      value: function value() {\n        this.stop = !0;\n      }\n    }, {\n      key: \"setScroll\",\n      value: function value(t, e) {\n        this.instance = o(o({}, this.instance), {}, {\n          scroll: {\n            x: t,\n            y: e\n          },\n          delta: {\n            x: t,\n            y: e\n          },\n          speed: 0\n        });\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        u(r(n.prototype), \"destroy\", this).call(this), this.stopScrolling(), this.html.classList.remove(this.smoothClass), this.vs.destroy(), this.destroyScrollBar(), window.removeEventListener(\"keydown\", this.checkKey, !1);\n      }\n    }]), n;\n  }(b);\n\n  return function () {\n    function e() {\n      var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      t(this, e), this.options = i, Object.assign(this, y, i), this.smartphone = y.smartphone, i.smartphone && Object.assign(this.smartphone, i.smartphone), this.tablet = y.tablet, i.tablet && Object.assign(this.tablet, i.tablet), this.smooth || \"horizontal\" != this.direction || console.warn(\" `smooth:false` & `horizontal` direction are not yet compatible\"), this.tablet.smooth || \"horizontal\" != this.tablet.direction || console.warn(\" `smooth:false` & `horizontal` direction are not yet compatible (tablet)\"), this.smartphone.smooth || \"horizontal\" != this.smartphone.direction || console.warn(\" `smooth:false` & `horizontal` direction are not yet compatible (smartphone)\"), this.init();\n    }\n\n    return i(e, [{\n      key: \"init\",\n      value: function value() {\n        if (this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || \"MacIntel\" === navigator.platform && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint, this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint, this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet ? this.scroll = new ct(this.options) : this.scroll = new x(this.options), this.scroll.init(), window.location.hash) {\n          var t = window.location.hash.slice(1, window.location.hash.length),\n              e = document.getElementById(t);\n          e && this.scroll.scrollTo(e);\n        }\n      }\n    }, {\n      key: \"update\",\n      value: function value() {\n        this.scroll.update();\n      }\n    }, {\n      key: \"start\",\n      value: function value() {\n        this.scroll.startScroll();\n      }\n    }, {\n      key: \"stop\",\n      value: function value() {\n        this.scroll.stopScroll();\n      }\n    }, {\n      key: \"scrollTo\",\n      value: function value(t, e) {\n        this.scroll.scrollTo(t, e);\n      }\n    }, {\n      key: \"setScroll\",\n      value: function value(t, e) {\n        this.scroll.setScroll(t, e);\n      }\n    }, {\n      key: \"on\",\n      value: function value(t, e) {\n        this.scroll.setEvents(t, e);\n      }\n    }, {\n      key: \"off\",\n      value: function value(t, e) {\n        this.scroll.unsetEvents(t, e);\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        this.scroll.destroy();\n      }\n    }]), e;\n  }();\n});\n\n//# sourceURL=webpack://favour-v2/./src/lib/locomotive-scroll.min.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/lib/locomotive-scroll.min.js");
/******/ 	
/******/ })()
;